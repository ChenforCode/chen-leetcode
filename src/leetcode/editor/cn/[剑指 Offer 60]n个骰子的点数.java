package leetcode.editor.cn;

//把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 
//
// 
//
// 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 
//
// 
//
// 示例 1: 
//
// 输入: 1
//输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
// 
//
// 示例 2: 
//
// 输入: 2
//输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0
//.05556,0.02778] 
//
// 
//
// 限制： 
//
// 1 <= n <= 11 
// Related Topics 数学 动态规划 概率与统计 👍 330 👎 0

/**
 * 这道题这样理解，对于一个骰子，每个概率都是 1/6 1/6 1/6 1/6 1/6 1/6
 * 分别对用的点数为1 2 3 4 5 6
 * 然后看第二个筛子的结果应该是2 - 12 共计11个结果。例如对于结果7来说，他的结果
 * 来自于第一个骰子的7 - 1 = 6；7 - 2 = 5；7 - 3 = 4；7 - 4 = 3；7 - 5 = 2；
 * 和7 - 6 = 1，意思是，当前骰子扔了1，那么前一个就6，当前扔2，前一个扔5，以此类推。
 * <p>
 * 也就是f(2, 7)代表扔两个骰子，得到7的结果的概率，应该这样计算，1/6代表第二轮扔的概率
 * f(2, 7) = f(1,7-1) * 1/6 + f(1,7-2) * 6/1 + .... + f(1,7-6) * 1/6
 * 即这样-->
 * ![image-20220101201001471](https://gitee.com/Chenforcode/chen-imagebed/raw/master/img/20220101201001.png)
 * 这样就可以利用dp来进行计算，但是这样的问题是，会产生边界溢出，即f(2, 2)他的情况如果从
 * 1减到6的话，会产生f(2, -1) f(2, -2)的情况。
 * <p>
 * 因此我们想到了正向推导，刚才的反向推导是理解成，对于dp[2]的每一项，来推导dp[1]中
 * 谁给给我们带来贡献，然后计算。
 * 正向推导就是，遍历dp[1]的每一项，直接计算他会给dp[2]中的哪一项带来贡献。
 * 例如dp[1] = [1/6, 1/6, 1/6, 1/6, 1/6, 1/6]
 * 其中dp[1,1] = 1 / 6会给dp[2, 1+1], dp[2,1+2] dp[2, 1+3]等加到6带来贡献
 * dp[1, 2]也是给dp[2, 2 + 1...6]带来贡献，因此就可以直接利用dp[1]推导出后边的数据
 */

import java.util.Arrays;

class NgeTouZiDeDianShuLcof {
    public static void main(String[] args) {
        Solution solution = new NgeTouZiDeDianShuLcof().new Solution();
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public double[] dicesProbability(int n) {
            //构造初始的dp[] = 6 ... 1/6;
            double[] dp = new double[6];
            Arrays.fill(dp, 1.0 / 6);
            //从dp2计算到dpn
            for (int i = 2; i <= n; i++) {
                //加上这个骰子会产生多少个结果，作为新的dp
                double[] temp = new double[5 * i + 1];
                //对于dpi-1中的每一项都要计算他对dpi产生的贡献
                for (int j = 0; j < dp.length; j++) {
                    //下标是从0开始的，因为源dp中每一个都会产生贡献。下边是计算贡献
                    for (int k = 0; k < 6; k++) {
                        //由于每个dp会产生的贡献是1-6，即原有的dp[i]会产生贡献到
                        //对应下标增加0-5的6个新的dp中
                        //dp[i + 0] - dp[i + 5]，产生的贡献值就是 dp[i]，然后
                        //由于本次扔骰子也是一个1/6的概率，因此要乘上1/6。
                        //就是类似于dp[1,1]的概率是1/6，也就是他的贡献
                        //然后计算dp[2, 7]的时候由于扔出一个6的概率是1/6，所以就是
                        //dp[1,1] * 1/6(本次扔出6的概率)
                        temp[j + k] += dp[j] / 6.0;
                    }
                }
                dp = temp;
            }
            return dp;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}